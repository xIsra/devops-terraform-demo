name: Infrastructure Init
on:
  workflow_dispatch:
    inputs:
      namespace:
        description: "Target namespace/environment"
        type: choice
        options: [production, staging, testing]
        default: production

env:
  NAMESPACE: ${{ github.event.inputs.namespace || 'production' }}

jobs:
  infra-init:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: "v1.29.2"

      - uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.7.0"
          terraform_wrapper: false

      - name: Ensure terraform.tfvars exists
        run: |
          ENV_DIR="infra/envs/${{ env.NAMESPACE }}"
          if [ ! -f "$ENV_DIR/terraform.tfvars" ]; then
            if [ -f "$ENV_DIR/terraform.tfvars.example" ]; then
              echo "Creating terraform.tfvars from example..."
              cp "$ENV_DIR/terraform.tfvars.example" "$ENV_DIR/terraform.tfvars"
              echo "⚠️  Please edit $ENV_DIR/terraform.tfvars and configure your secrets"
            else
              echo "Error: terraform.tfvars.example not found in $ENV_DIR"
              exit 1
            fi
          fi

      - name: Update terraform.tfvars with OpenAI API key
        if: env.OPENAI_API_KEY != ''
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          ENV_DIR="infra/envs/${{ env.NAMESPACE }}"
          if [ -n "$OPENAI_API_KEY" ]; then
            if grep -q "^openai_api_key" "$ENV_DIR/terraform.tfvars"; then
              sed -i.bak "s|^openai_api_key.*|openai_api_key = \"$OPENAI_API_KEY\"|" "$ENV_DIR/terraform.tfvars"
              rm -f "$ENV_DIR/terraform.tfvars.bak"
            else
              echo "openai_api_key = \"$OPENAI_API_KEY\"" >> "$ENV_DIR/terraform.tfvars"
            fi
          fi

      - name: Terraform Init
        run: |
          ENV_DIR="infra/envs/${{ env.NAMESPACE }}"
          cd "$ENV_DIR"
          terraform init

      - name: Install Kind
        run: |
          if ! command -v kind &>/dev/null; then
            echo "Installing Kind..."
            curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.20.0/kind-linux-amd64
            chmod +x ./kind
            sudo mv ./kind /usr/local/bin/kind
          fi

      - name: Create Kind cluster
        run: |
          ENV_DIR="infra/envs/${{ env.NAMESPACE }}"
          cd "$ENV_DIR"

          CLUSTER_NAME=$(grep '^cluster_name' terraform.tfvars | cut -d'"' -f2 || echo "devops-demo")

          # Check if cluster exists
          if kind get clusters 2>/dev/null | grep -q "^${CLUSTER_NAME}$"; then
            echo "Cluster ${CLUSTER_NAME} already exists"
            kind export kubeconfig --name ${CLUSTER_NAME} 2>/dev/null || true
          else
            echo "Creating Kind cluster..."
            terraform apply -var-file=terraform.tfvars \
              -target=kind_cluster.this \
              -auto-approve || {
              # Fallback: create cluster directly if Terraform fails
              if ! kind get clusters 2>/dev/null | grep -q "^${CLUSTER_NAME}$"; then
                echo "Creating cluster directly with kind..."
                cat > /tmp/kind-config.yaml <<EOF
kind: Cluster
apiVersion: kind.x-k8s.io/v1alpha4
nodes:
- role: control-plane
  kubeadmConfigPatches:
  - |
    kind: InitConfiguration
    nodeRegistration:
      kubeletExtraArgs:
        node-labels: "ingress-ready=true"
  extraPortMappings:
  - containerPort: 80
    hostPort: 80
    protocol: TCP
  - containerPort: 443
    hostPort: 443
    protocol: TCP
- role: worker
- role: worker
EOF
                kind create cluster --name ${CLUSTER_NAME} --config /tmp/kind-config.yaml
                rm -f /tmp/kind-config.yaml
              fi
            }
            kind export kubeconfig --name ${CLUSTER_NAME} 2>/dev/null || true
          fi

      - name: Initialize base infrastructure
        run: |
          ENV_DIR="infra/envs/${{ env.NAMESPACE }}"
          cd "$ENV_DIR"

          # Deploy image registry repositories first
          terraform apply -var-file=terraform.tfvars \
            -target=module.image_registry \
            -auto-approve

          # Deploy base infrastructure (namespaces, database, ingress)
          terraform apply -var-file=terraform.tfvars \
            -target=module.namespace \
            -target=module.postgresql \
            -target=null_resource.wait_for_ingress \
            -auto-approve
