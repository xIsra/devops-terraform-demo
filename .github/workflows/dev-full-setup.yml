name: Dev Full Setup
on:
  workflow_dispatch:
    inputs:
      namespace:
        description: "Target namespace/environment"
        type: choice
        options: [production, staging, testing]
        default: production

env:
  NAMESPACE: ${{ github.event.inputs.namespace || 'production' }}

jobs:
  dev-full-setup:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: "v1.29.2"

      - name: Configure kubectl for remote cluster
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBECONFIG }}" > ~/.kube/config
          chmod 600 ~/.kube/config
          kubectl config use-context kind-devops-demo || kubectl config current-context

      - uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.7.0"
          terraform_wrapper: false

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Ensure terraform.tfvars exists
        run: |
          ENV_DIR="infra/envs/${{ env.NAMESPACE }}"
          if [ ! -f "$ENV_DIR/terraform.tfvars" ]; then
            if [ -f "$ENV_DIR/terraform.tfvars.example" ]; then
              echo "Creating terraform.tfvars from example..."
              cp "$ENV_DIR/terraform.tfvars.example" "$ENV_DIR/terraform.tfvars"
              echo "⚠️  Please edit $ENV_DIR/terraform.tfvars and configure your secrets"
            else
              echo "Error: terraform.tfvars.example not found in $ENV_DIR"
              exit 1
            fi
          fi

      - name: Update terraform.tfvars with OpenAI API key
        if: env.OPENAI_API_KEY != ''
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          ENV_DIR="infra/envs/${{ env.NAMESPACE }}"
          # Update openai_api_key if secret is provided
          if [ -n "$OPENAI_API_KEY" ]; then
            if grep -q "^openai_api_key" "$ENV_DIR/terraform.tfvars"; then
              sed -i.bak "s|^openai_api_key.*|openai_api_key = \"$OPENAI_API_KEY\"|" "$ENV_DIR/terraform.tfvars"
              rm -f "$ENV_DIR/terraform.tfvars.bak"
            else
              echo "openai_api_key = \"$OPENAI_API_KEY\"" >> "$ENV_DIR/terraform.tfvars"
            fi
          fi

      - name: Terraform Init
        run: |
          ENV_DIR="infra/envs/${{ env.NAMESPACE }}"
          cd "$ENV_DIR"
          terraform init

      - name: Initialize Infrastructure
        run: |
          ENV_DIR="infra/envs/${{ env.NAMESPACE }}"
          cd "$ENV_DIR"

          # Ensure cluster exists first
          terraform apply -var-file=terraform.tfvars \
            -target=kind_cluster.this \
            -auto-approve || true

          # Deploy registry first (needed for image pushes)
          terraform apply -var-file=terraform.tfvars \
            -target=module.docker_registry \
            -auto-approve

          # Deploy base infrastructure (namespaces, database, observability)
          terraform apply -var-file=terraform.tfvars \
            -target=module.namespace \
            -target=module.postgresql \
            -target=module.observability \
            -target=null_resource.wait_for_ingress \
            -auto-approve

      - name: Wait for registry to be ready
        run: |
          echo "Waiting for Docker registry to be ready..."
          kubectl wait --namespace docker-registry \
            --for=condition=ready pod \
            --selector=app=docker-registry \
            --timeout=120s || echo "Warning: Registry may not be ready yet"

      - name: Build and push images to registry
        run: |
          # Start port-forward in background
          kubectl port-forward --namespace docker-registry svc/docker-registry-nodeport 5000:5000 > /dev/null 2>&1 &
          PORT_FORWARD_PID=$!
          sleep 3

          REGISTRY="localhost:5000"

          # Test registry connection
          if ! curl -f http://${REGISTRY}/v2/ > /dev/null 2>&1; then
            echo "Warning: Could not connect to registry, retrying..."
            sleep 2
          fi

          # Build and tag resume-agent
          cd python/resume-agent
          docker build -t resume-agent:latest .
          docker tag resume-agent:latest ${REGISTRY}/resume-agent:latest
          docker push ${REGISTRY}/resume-agent:latest

          # Build and tag server
          cd ../../typescript
          docker build -t server:latest -f apps/server/Dockerfile .
          docker tag server:latest ${REGISTRY}/server:latest
          docker push ${REGISTRY}/server:latest

          # Build and tag migration
          docker build -t server-migration:latest -f apps/server/Dockerfile.migration .
          docker tag server-migration:latest ${REGISTRY}/server-migration:latest
          docker push ${REGISTRY}/server-migration:latest

          # Build and tag web
          docker build -t web:latest -f apps/web/Dockerfile \
            --build-arg VITE_SERVER_URL=https://devops-demo.local/api .
          docker tag web:latest ${REGISTRY}/web:latest
          docker push ${REGISTRY}/web:latest

          echo "✅ Pushed all images to registry"

          # Cleanup port-forward
          kill $PORT_FORWARD_PID 2>/dev/null || true

      - name: Deploy all services
        run: |
          ENV_DIR="infra/envs/${{ env.NAMESPACE }}"
          cd "$ENV_DIR"

          # Deploy migration first (for server)
          terraform apply -var-file=terraform.tfvars \
            -target=module.server_migration \
            -auto-approve || true

          # Wait for migration if it exists
          JOB_NAME="server-migration-latest"
          if kubectl get job "$JOB_NAME" -n "${{ env.NAMESPACE }}" &>/dev/null; then
            echo "Waiting for migration job to complete..."
            kubectl wait --for=condition=complete --timeout=300s job/"$JOB_NAME" -n "${{ env.NAMESPACE }}" || true
          fi

          # Deploy all services
          terraform apply -var-file=terraform.tfvars -auto-approve

      - name: Verify deployments
        run: |
          NAMESPACE="${{ env.NAMESPACE }}"
          echo "Checking deployment status..."
          kubectl get deployments -n "$NAMESPACE" || true
          kubectl get pods -n "$NAMESPACE" || true
